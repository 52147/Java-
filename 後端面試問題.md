# 2023 後端面試問題

## 1. Objeact Oriented Design

- 繼承
- 封裝
- 多態

## 編譯器Compiler 和 直譯器Interpreter
編譯器: 一次性把原代碼轉換成更低階的代碼(二進制碼、機器碼)，轉換後不要執行。   
直譯器有以下三種方式執行source code:   
1. 會直接讀取原代碼，並直接生成指令並讓計算機硬件執行，不會轉換成更低階的代碼。       
2. 將source code轉換成中間語言(intermediate representation) 之後立即執行。    
3. 執行編譯器儲存並於直譯器匹配過的預編譯的代碼。    

https://huang-jerryc.com/2016/11/20/do-you-konw-the-different-between-compiler-and-interpreter/
## 資料庫的正規畫
## Restful API
Restful API 為服務端與客戶端透過網際網路(表現層)交換資訊的介面。   

Restful 是 目前最流行的API設計規範。
API 是應用程序間的交互接口。     

流程:   

客戶端發送請求去要求資源(json、html)，資源由URI所指定，Restful API收到http request(GET、POST、PUT、DELETE)，以服務端能理解的方式格式化請求(SELECT、CREATE、UPDATE、DELETE)，服務端對用戶端進行身分驗證，並確認客戶端是否有權發出請求，服務端接收請求並在內部處理，再通過Restful Api回應(response)給客戶端，資料的表現形式有XML、HTML、JSON。   


客戶端請求包含:
1. URL: 指定資源路徑。
2. Http method: 告訴服務端需要對資源最什麼。
http request 所對應的 資源操作:   
- GET : SELECT
- POST : CREATE
- PUT : UPDATE
- DELETE : DELETE   
3. http 標頭     
   
伺服器回應包含:  
1. 狀態行:     
   - 包含3位數狀態碼，用於傳達請求成功或失敗
   - 常見的狀態碼:
     - 200：一般成功回應
     - 201：POST 方法成功回應
     - 400：伺服器無法處理的錯誤請求
     - 404：找不到資源
3. 郵件正文:    
   - 回應xml或json資訊格式的正文
5. 標頭    


Restful API 設計規範的六大原則:    
1. 統一接口Uniform Interface   
   - 以資源為基礎: 每個資源都可以透過URI存取
   - 
3. 專注於客戶端與服務端的分離
4. 無狀態(staleness): 服務端不記錄客戶端狀態信息，
5. 可緩存
6. 分層系統
7. 按需代碼   
https://aws.amazon.com/tw/what-is/restful-api/?nc1=h_ls     
https://zhuanlan.zhihu.com/p/334809573    
https://medium.com/itsems-frontend/api-%E6%98%AF%E4%BB%80%E9%BA%BC-restful-api-%E5%8F%88%E6%98%AF%E4%BB%80%E9%BA%BC-a001a85ab638
## mongodb 與 mySQL
## multithreading 與 multiprocessing
## Java即时编译器原理解析及实践
在執行時期，直接把byte code轉換成machine code，JVM使用這項技術來改善效能。
java 及時(just in time)編譯過程:   

1. 由javac把java編譯成byte code，在這個過程中進行詞法、語法、語意的分析。   
2. 接下來JVM逐條把byte code 解釋執行，在這個過程中JVM 進行資訊收集，將符合熱點代碼的byte code進行編譯(轉換成 machine code)，熱點代碼為方法或代碼塊在一定的時間內，超過JVM閥值的調用次數。   
   
   


https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html
## concurrency
至少有兩個計算在同時進行，計算的結果同時獲得。

## Session 與 Cookie
Http 是一種無狀態的協議，無狀態協議代表瀏覽器不會保存任何會話信息，所以無法確保每一次的會話是同一個用戶發出，服務端無法確認訪問者信息，因此瀏覽器會和服務端進行"會話跟蹤"，代表在進行一些特殊用戶權限才有的操作時，會將用戶狀態用cookie 或session保存起來，所以cookie和session 是用來儲存用戶狀態的機制。    

### Cookie
Cookie 是一種用於客戶端和服務端進行會話驗證的憑證。   
Cookie 的設置(set-Cookie):   
 1. 從客戶端設置: 客戶端通過js設置
 2. 從服務端設置: 服務端通過http響應頭(http response header)設置

### Session
Session 是基於cookie 的 紀錄服務端和客戶端的狀態的機制。    
Session data 儲存在服務端，Session id 儲存在客戶端的cookie上。    
Session 驗證客戶端和服務端的過程:   

### Cookie 和 Session 的差異
1. 安全性: session的安全性較高，因為session只能通過服務端設置，所以一般用於驗證用戶登陸狀態，而cookie可以通過客戶端設置。
2. 適用性: session 可以儲存任意數據類型，而cookie只能儲存字符串數據。
3. 有效期: session 的時效短，而cookie可以設置任意時間失效。
4. 繼承性: 客戶端設置cookie，如果需要用於驗證，就需要服務端設置session。   

https://juejin.cn/post/6844903822867824647
## JavaEE && JavaSE
## git fetch 和 git pull 的差異
git fetch: 從遠程倉庫獲得最新版本放到本地倉庫(不會git merge、git merge 是 合併兩個分支)    
git pull: 從遠程倉庫獲得最新版本並merge到本地倉庫。   
差異:   
git fetch 比 git pull更安全，因為我們可以先比較本地倉庫和遠程倉庫的區別再做合併。    
https://www.cnblogs.com/emanlee/p/14832905.html#:~:text=fetch%E5%90%8Cpull%E7%9A%84%E5%8C%BA%E5%88%AB,%E5%90%8E%EF%BC%8C%E9%80%89%E6%8B%A9%E6%80%A7%E7%9A%84%E5%90%88%E5%B9%B6%E3%80%82   
https://blog.csdn.net/riddle1981/article/details/74938111#:~:text=git%20fetch%E6%98%AF%E5%B0%86%E8%BF%9C%E7%A8%8B,%E5%92%8Cgit%20pull%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82
## 2. 設計一個搶購系統
大量用戶在同一時間區段，搶購同一商品。
可以用以下方式處理瞬時高併發(concurrency)的狀況:  
1. 頁面靜態化
2. CDN 加速
3. 緩存
4. mq異步處理
5. 限流
6. 分布式鎖   

https://www.teqng.com/2021/09/07/%e9%9d%a2%e9%9c%b8%ef%bc%9a%e7%a7%92%e6%9d%80%e7%b3%bb%e7%bb%9f%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%ef%bc%9f/

## 3. Redis 緩存
如果有大量用戶需要搶少量商品，這種為讀多寫少的狀況，商品的數量不夠用戶的下單數，如果有數十萬的請求在同時發生，數據庫可能會無法運作，因為數據庫的連接資源非常有限，無法同時支持這麼多連接。ex: mySql    

這時我們可以運用redis 來緩存商品的id、名稱、規格、庫存，同時數據庫中也要有相關信息。    

顧客下單，商品id傳入redis緩存以查詢庫存量，得到庫存量足夠後再下單，接著將訂單資料放入DB。   
如果在緩存中沒有查到商品，換到數據庫中查詢，如果在數據庫中查詢到商品，將商品放入緩存，接著在下單把訂單資料放入DB。 (有緩存擊穿問題)

### 問題: 緩存擊穿
如果同一時間對同一商品有大量請求，這些請求同時去緩存查詢有沒有商品資訊，然後剛好商品(key)過期，再緩存中失效，沒有在緩存查到商品後，大量請求又同時訪問數據庫做查詢
=> 數據庫無法處理大量請求，掛掉。    

### 解決方式: 分布式鎖
如果在緩存中沒有查詢到商品資訊，獲取分布式鎖，如果獲取成功，從數據庫中查詢商品，如果商品存在，再將品放入緩存中，下訂單。
### 問題: 緩存雪崩


### 問題: 緩存穿透
數據庫和緩存中都沒有商品資訊。這樣緩存沒有起到作用，因為每一次都會先查緩存然後再查數據庫。   

### 解決方式: 布隆過濾器   
不用分布式鎖，利用布隆過濾器查詢商品id，如果存在此id，允許從緩存中查詢商品，如果不存在，返回失敗。(問題: 如果緩存更新頻繁，無法確保布隆過濾器也同步更新)    

解決 : 商品如果不存在，將不存在的商品id 放入redis，這樣如果下一次再遇到同一商品，緩存會先返回空數據。    
全部流程: 顧客下單，商品id傳入redis緩存以查詢庫存量，商品如果不存在，將不存在的商品id 放入redis，如果商品存在，將訂單資料放入DB。   
https://www.bilibili.com/video/BV1aP4y197KT/?spm_id_from=333.337.search-card.all.click
## 4. URL 是什麼
URL（Uniform Resource Locator），用於定位網路上的資源位置，又稱網址。    

語法規則:   
scheme://host.domain:port/path/filename   

- schema: 定義網路服務的類型，最常見的協議為http，https是利用SSL/TLS來加密數據包，又稱「非對稱式加密」的網路傳輸協議。
- host: 定義域主機(http 默認主機為 www)
- domain: 定義網路域名，例如: github.com、wikipedia.org
- port: 定義主機上的端口號(http 的默認端口號是80)
- path: 定義服務器上的路徑(如果省略，檔案必須位於跟目錄中)
- filename: 定義檔案名稱


## 5. 從瀏覽器輸入url之後到網頁的呈現中間的過程
### 1. DNS 解析域名
DNS 協議為Distributed database，它將域名(domain name)解析成ip 地址或將ip地址轉換成域名。原因: 域名(用英文和數代表一台主機)更符合人類的記憶習慣，帶如果要使用計算機去辨認，ip address(一串數字) 計算機比較容易辨識。    

ip 地址: ip 協議提供的一種統一的地址格式，網路上的每一台主機都有一個ip 地址。ip 地址為32位於的2進制數，例如本機的ip 地址為 127.0.0.1。

### 2. TCP 三次握手
在客戶端發送訊息之前會先發起TCP 三次握手，已同步客戶端的序列號和確認號，並交換TCP窗口的信息。    

需要TCP 三次握手的原因:    
為了防止已失效的連接請求報文佑傳送到服務端，而產生錯誤。    

TCP 三次握手過程:   



### 3. 發送http請求

### 4. 服務器處理請求並返回http報文
服務器處理階段  
服務器是網路中的高性能計算機，他負責處理客戶端提交的請求，並提供相應的服務。比如，網頁服務、文件下載服務、郵件服務、視頻服務。   
客戶端的功能為，看視頻、聽音樂、瀏覽網頁。   
每台服務器上都會安裝處理請求的網頁伺服器(web server)。常見的網頁伺服器有apache、nginx、IIS、Lighttpd。    

Web server擔任控管的腳色，對於不同用戶發送的請求，會結合配置文件，把不同請求委託給服務器上處理相應請求的程序進行處理，然後在返回後台程序處理產生的結果作為響應。   

MVC 後臺處理階段    
後臺開發有很多框架，但大部分還是用MVC設計模式的方式搭建。    
MVC 是一種設計框架，將應用程序分為三個部分: 模型(moodel)，視圖(view)，控制器(controller)。   

- 模型負責數據交互
- 試圖提供操作介面






https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/
## 6. 設計一個宣傳系統 onboarding system
### 設計Restful API

GET /api/products   
  取得全部的商品   
GET /api/product/{id}   
  取得對應 id 的商品   
PUT /api/product    
  新增商品    
POST /api/product/{id}    
  更新對應 id 的商品資訊   
DELETE /api/product/{id}    
  刪除對應 id 的商品資訊   


## 7. DB中的ACID
為DB 在寫入或更新資料的過程中，為保證交易是正確的四個特性。     
一個事務為一系列的db操作組成的邏輯過程，具有ACID的四個特性，
例如: 銀行轉帳為db的一個事務(transaction)，因為從原帳戶扣除金額，然後向目標帳戶增加金額，這兩個資料庫的操作，構成一個完整的邏輯過程，不可拆分。   

1. 原子性: 一個事務的所有操作，部會結束在中間的某個過程，如果事務在執行過程中發生錯誤，會被回滾到開始前的狀態，因為事務不可分割、化簡。由 undolog做保證，它記錄了需要回滾(roll back)的訊息，事務回滾時撤銷已經執行的sql。
2. 一制性:修改的數據必須滿足db的規則，由滿足其他三個特點來保證。
3. 隔離性: 為了防止多個事務併發執行時，由於交叉執行而導致數據不一致。由MVCC來保證。
4. 持久性: 事務結束處理後，修改的數據就算系統故障也不會丟失。由redolog來保證，mySQL修改數據時，會在redolog中記錄一份日誌，就算數據沒有保存成功，只要日誌保存成功了，修改後的數據不會丟失。   

https://www.bilibili.com/video/BV1Vb4y177wm/?spm_id_from=333.337.search-card.all.click
## 8. Rate limiter 限流算法

## 二階段提交 (Two-phase commit protocol)


## Scrum Process
角色:   

1. scrum master: 保證敏捷開發流程
2. PM: 整理需求，確定需求優先及，決定開發任務，對產品質量的把關
3. Dev team: 開發團隊    

特點:   
敏捷開發以用戶需求為核心，將項目切分為堆個子項目，以迭代的方式進行開發，每個子項目都經過測試，具備可視、可集成、可運行、可使用的特性。     

流程:   
1. PM 進行需求分析，寫出需求文黨(product backlog)
2. 團隊進行需求討論(sprint planning meeting)，給出排期，接著進入開發階段(sprint)
sprint (1 到4周)    
4. 寫測試用例
5. 每日站會交流
6. 功能評估
7. 整個迭代過程回顧，找出每個迭代間的差距，優化迭代流程    

https://zhuanlan.zhihu.com/p/450979517
