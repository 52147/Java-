# 2023 後端面試問題

## 1. Objeact Oriented Design

- 繼承
- 封裝
- 多態

## 編譯器Compiler 和 直譯器Interpreter
編譯器: 把原代碼轉換成更低階的代碼(二進制碼、機器碼)，轉換後不要執行。   
直譯器: 會直接讀取原代碼，並直接生成指令並讓計算機硬件執行，不會轉換成更低階的代碼。   

https://huang-jerryc.com/2016/11/20/do-you-konw-the-different-between-compiler-and-interpreter/
## 資料庫的正規畫
## Restful API
Restful 是 目前最流行的API設計規範。客戶端發送請求去要求資源(html、json、html)，Restful API收到http request(GET、POST、PUT、DELETE)，判斷對應的資源的操作(SELECT、CREATE、UPDATE、DELETE)，給予服務端指示去db提取資料，並在通過Restful Api回應(response)給客戶端。   

http request 所對應的 資源操作:   
- GET : SELECT
- POST : CREATE
- PUT : UPDATE
- DELETE : DELETE   

Restful API 設計規範的六大原則:    
1. 統一接口Uniform Interface
2. 專注於客戶端與服務端的分離
3. 無狀態(staleness): 服務端不記錄客戶端狀態信息，
4. 可緩存
5. 分層系統
6. 按需代碼   

https://zhuanlan.zhihu.com/p/334809573    
https://medium.com/itsems-frontend/api-%E6%98%AF%E4%BB%80%E9%BA%BC-restful-api-%E5%8F%88%E6%98%AF%E4%BB%80%E9%BA%BC-a001a85ab638
## mongodb 與 mySQL
## multithreading 與 multiprocessing
## Java即时编译器原理解析及实践
https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html
## concurrency
至少有兩個計算在同時進行，計算的結果同時獲得。

## Session 與 Cookie
Http 是一種無狀態的協議，無狀態協議代表瀏覽器不會保存任何會話信息，所以無法確保每一次的會話是同一個用戶發出，服務端無法確認訪問者信息，因此瀏覽器會和服務端進行"會話跟蹤"，代表在進行一些特殊用戶權限才有的操作時，會將用戶狀態用cookie 或session保存起來，所以cookie和session 是用來儲存用戶狀態的機制。    

### Cookie
Cookie 是一種用於客戶端和服務端進行會話驗證的憑證。   
Cookie 的設置:
1. 從客戶端設置:
2. 從服務端設置:

### Session
Session 是基於cookie 的 紀錄服務端和客戶端的狀態的機制。    
Session data 儲存在服務端，Session id 儲存在客戶端的cookie上。    
Session 驗證客戶端和服務端的過程:   

### Cookie 和 Session 的差異
1. 安全性:
2. 適用性:
3. 有效期:
4. 繼承性:
https://juejin.cn/post/6844903822867824647
## JavaEE && JavaSE
## git fetch 和 git pull 的差異
git fetch: 從遠程倉庫獲得最新版本放到本地倉庫(不會git merge、git merge 是 合併兩個分支)    
git pull: 從遠程倉庫獲得最新版本並merge到本地倉庫。   
差異:   
git fetch 比 git pull更安全，因為我們可以先比較本地倉庫和遠程倉庫的區別再做合併。    
https://www.cnblogs.com/emanlee/p/14832905.html#:~:text=fetch%E5%90%8Cpull%E7%9A%84%E5%8C%BA%E5%88%AB,%E5%90%8E%EF%BC%8C%E9%80%89%E6%8B%A9%E6%80%A7%E7%9A%84%E5%90%88%E5%B9%B6%E3%80%82   
https://blog.csdn.net/riddle1981/article/details/74938111#:~:text=git%20fetch%E6%98%AF%E5%B0%86%E8%BF%9C%E7%A8%8B,%E5%92%8Cgit%20pull%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82
## 2. 設計一個搶購系統
大量用戶在同一時間區段，搶購同一商品。
可以用以下方式處理瞬時高併發(concurrency)的狀況:  
1. 頁面靜態化
2. CDN 加速
3. 緩存
4. mq異步處理
5. 限流
6. 分布式鎖   

https://www.teqng.com/2021/09/07/%e9%9d%a2%e9%9c%b8%ef%bc%9a%e7%a7%92%e6%9d%80%e7%b3%bb%e7%bb%9f%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%ef%bc%9f/

## 3. Redis 緩存
如果有大量用戶需要搶少量商品，這種為讀多寫少的狀況，商品的數量不夠用戶的下單數，如果有數十萬的請求在同時發生，數據庫可能會無法運作，因為數據庫的連接資源非常有限，無法同時支持這麼多連接。ex: mySql    

這時我們可以運用redis 來緩存商品的id、名稱、規格、庫存，同時數據庫中也要有相關信息。    

顧客下單，商品id傳入redis緩存以查詢庫存量，得到庫存量足夠後再下單，接著將訂單資料放入DB。   
如果在緩存中沒有查到商品，換到數據庫中查詢，如果在數據庫中查詢到商品，將商品放入緩存，接著在下單把訂單資料放入DB。 (有緩存擊穿問題)

### 問題: 緩存擊穿
如果同一時間對同一商品有大量請求，這些請求同時去緩存查詢有沒有商品資訊，然後剛好商品(key)過期，再緩存中失效，沒有在緩存查到商品後，大量請求又同時訪問數據庫做查詢
=> 數據庫無法處理大量請求，掛掉。    

### 解決方式: 分布式鎖
如果在緩存中沒有查詢到商品資訊，獲取分布式鎖，如果獲取成功，從數據庫中查詢商品，如果商品存在，再將品放入緩存中，下訂單。
### 問題: 緩存雪崩


### 問題: 緩存穿透
數據庫和緩存中都沒有商品資訊。這樣緩存沒有起到作用，因為每一次都會先查緩存然後再查數據庫。   

### 解決方式: 布隆過濾器   
不用分布式鎖，利用布隆過濾器查詢商品id，如果存在此id，允許從緩存中查詢商品，如果不存在，返回失敗。(問題: 如果緩存更新頻繁，無法確保布隆過濾器也同步更新)    

解決 : 商品如果不存在，將不存在的商品id 放入redis，這樣如果下一次再遇到同一商品，緩存會先返回空數據。    
全部流程: 顧客下單，商品id傳入redis緩存以查詢庫存量，商品如果不存在，將不存在的商品id 放入redis，如果商品存在，將訂單資料放入DB。   
https://www.bilibili.com/video/BV1aP4y197KT/?spm_id_from=333.337.search-card.all.click
## 4. URL 是什麼
URL（Uniform Resource Locator），用於定位網路上的資源位置，又稱網址。    

語法規則:   
scheme://host.domain:port/path/filename   

- schema: 定義網路服務的類型，最常見的協議為http，https是利用SSL/TLS來加密數據包，又稱「非對稱式加密」的網路傳輸協議。
- host: 定義域主機(http 默認主機為 www)
- domain: 定義網路域名，例如: github.com、wikipedia.org
- port: 定義主機上的端口號(http 的默認端口號是80)
- path: 定義服務器上的路徑(如果省略，檔案必須位於跟目錄中)
- filename: 定義檔案名稱


## 5. 從瀏覽器輸入url之後到網頁的呈現中間的過程
### 1. DNS 解析域名
DNS 協議為Distributed database，它將域名(domain name)解析成ip 地址或將ip地址轉換成域名。原因: 域名(用英文和數代表一台主機)更符合人類的記憶習慣，帶如果要使用計算機去辨認，ip address(一串數字) 計算機比較容易辨識。    

ip 地址: ip 協議提供的一種統一的地址格式，網路上的每一台主機都有一個ip 地址。ip 地址為32位於的2進制數，例如本機的ip 地址為 127.0.0.1。

### 2. TCP 三次握手
在客戶端發送訊息之前會先發起TCP 三次握手，已同步客戶端的序列號和確認號，並交換TCP窗口的信息。    

需要TCP 三次握手的原因:    
為了防止已失效的連接請求報文佑傳送到服務端，而產生錯誤。    

TCP 三次握手過程:   



### 3. 發送http請求

### 4. 服務器處理請求並返回http報文
服務器處理階段  
服務器是網路中的高性能計算機，他負責處理客戶端提交的請求，並提供相應的服務。比如，網頁服務、文件下載服務、郵件服務、視頻服務。   
客戶端的功能為，看視頻、聽音樂、瀏覽網頁。   
每台服務器上都會安裝處理請求的網頁伺服器(web server)。常見的網頁伺服器有apache、nginx、IIS、Lighttpd。    

Web server擔任控管的腳色，對於不同用戶發送的請求，會結合配置文件，把不同請求委託給服務器上處理相應請求的程序進行處理，然後在返回後台程序處理產生的結果作為響應。   

MVC 後臺處理階段    
後臺開發有很多框架，但大部分還是用MVC設計模式的方式搭建。    
MVC 是一種設計框架，將應用程序分為三個部分: 模型(moodel)，視圖(view)，控制器(controller)。   

- 模型負責數據交互
- 試圖提供操作介面






https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/
## 6. 設計一個宣傳系統 onboarding system
### 設計Restful API

GET /api/products   
  取得全部的商品   
GET /api/product/{id}   
  取得對應 id 的商品   
PUT /api/product    
  新增商品    
POST /api/product/{id}    
  更新對應 id 的商品資訊   
DELETE /api/product/{id}    
  刪除對應 id 的商品資訊   


## 7. DB中的ACID
為DB 在寫入或更新資料的過程中，為保證交易是正確的四個特性。
例如: 銀行轉帳為db的一個事務(transaction)，一個事務為一系列的db操作組成的邏輯過程，具有ACID的四個特性，因為從原帳戶扣除金額，然後像目標帳戶扣除金額，這兩個資料庫的操作，構成一個完整的邏輯過程，不可拆分。   

1. 原子性: 一個事務的所有操作，部會結束在中間的某個過程，如果事務在執行過程中發生錯誤，會被回滾到開始前的狀態，因為事務不可分割、化簡。由 undolog做保證，它記錄了需要回滾(roll back)的訊息，事務回滾時撤銷已經執行的sql。
2. 一制性:修改的數據必須滿足db的規則，由滿足其他三個特點來保證。
3. 隔離性: 防止多個事務併發執行時，由於交叉執行而導致數據不一致。由MVCC來保證。
4. 持久性: 事務結束處理後，修改的數據就算系統故障也不會丟失。由redolog來保證，mySQL修改數據時，會在redolog中記錄一份日誌，就算數據沒有保存成功，只要日誌保存成功了，修改後的數據不會丟失。   

https://www.bilibili.com/video/BV1Vb4y177wm/?spm_id_from=333.337.search-card.all.click
## 8. Rate limiter 限流算法

